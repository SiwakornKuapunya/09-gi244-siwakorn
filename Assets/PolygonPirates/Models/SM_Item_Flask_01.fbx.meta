WeakEq;
  if (__seen[_StrongEq])
    return _StrongEq;
  if (__seen[_PartialOrd])
    return _PartialOrd;
  if (__seen[_WeakOrd])
    return _WeakOrd;
  return _StrongOrd;
}

template <class ..._Ts>
constexpr auto __get_comp_type() {
  using _CCC = _ClassifyCompCategory;
  constexpr array<_CCC, sizeof...(_Ts)> __type_kinds{{__comp_detail::__type_to_enum<_Ts>()...}};
  constexpr _CCC _Cat = sizeof...(_Ts) == 0 ? _StrongOrd
      : __compute_comp_type(__type_kinds);
  if constexpr (_Cat == _None)
    return void();
  else if constexpr (_Cat == _WeakEq)
    return weak_equality::equivalent;
  else if constexpr (_Cat == _StrongEq)
    return strong_equality::equivalent;
  else if constexpr (_Cat == _PartialOrd)
    return partial_ordering::equivalent;
  else if constexpr (_Cat == _WeakOrd)
    return weak_ordering::equivalent;
  else if constexpr (_Cat == _StrongOrd)
    return strong_ordering::equivalent;
  else
    static_assert(_Cat != _Cat, "unhandled case");
}
} // namespace __comp_detail

// [cmp.common], common comparison category type
template<class... _Ts>
struct _LIBCPP_TEMPLATE_VIS common_comparison_category {
  using type = decltype(__comp_detail::__get_comp_type<_Ts...>());
};

template<class... _Ts>
using common_comparison_category_t = typename common_comparison_category<_Ts...>::type;

// [cmp.alg], comparison algorithms
// TODO: unimplemented
template<class _Tp> constexpr strong_ordering strong_order(const _Tp& __lhs, const _Tp& __rhs);
template<class _Tp> constexpr weak_ordering weak_order(const _Tp& __lhs, const _Tp& __rhs);
template<class _Tp> constexpr partial_ordering partial_order(const _Tp& __lhs, const _Tp& __rhs);
templat